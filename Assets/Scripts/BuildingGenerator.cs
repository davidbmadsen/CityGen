using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class BuildingGenerator : MonoBehaviour
{
    // Class for generating buildings based on the road network generated by the RoadNetwork class
    // Generate some houses ya bish
    System.Random rnd = new System.Random();
    Mesh mesh;

    List<OrientedPoint> OffsetPath(List<OrientedPoint> path, int offset, bool orientation)
    {
        // Function for offsetting a path perpendicular in either right (orientation = true) 
        // or left of the original path

        List<OrientedPoint> offsetPath = new List<OrientedPoint>();

        if (orientation)
        {
            foreach (OrientedPoint point in path)
            {
                offsetPath.Add(new OrientedPoint(
                    point.position + point.rotation * Vector3.right * offset,
                    point.rotation,
                    0,
                    new List<OrientedPoint>()
                ));
            }
        }
        else
        {
            foreach (OrientedPoint point in path)
            {
                offsetPath.Add(new OrientedPoint(
                    point.position + point.rotation * Vector3.left * offset,
                    point.rotation,
                    0,
                    new List<OrientedPoint>()
                ));
            }
        }

        return offsetPath;
    }

    List<OrientedPoint> OffsetPathUp(List<OrientedPoint> path, int height)
    {
        List<OrientedPoint> offsetPath = new List<OrientedPoint>();
        foreach (OrientedPoint point in path)
        {
            offsetPath.Add(new OrientedPoint(
                point.position + point.rotation * Vector3.up * height,
                point.rotation,
                0,
                new List<OrientedPoint>()
            ));
        }

        return offsetPath;
    }

    Mesh CurvedHouse(List<OrientedPoint> path, int distanceFromRoad, int width, int height, bool orientation)
    {
        /*
        Function for creating prismatic houses that curve along a path
        */

        // Create offset paths
        // Bottom face
        List<OrientedPoint> side = OffsetPath(path, distanceFromRoad, orientation);
        List<OrientedPoint> edge = OffsetPath(path, width, orientation);

        // Top face
        List<OrientedPoint> sideTop = OffsetPathUp(side, height);
        List<OrientedPoint> edgeTop = OffsetPathUp(edge, height);


        // Front face
        List<OrientedPoint> frontBottom = new List<OrientedPoint>();
        frontBottom.Add(side[0]); frontBottom.Add(edge[0]);

        List<OrientedPoint> frontTop = new List<OrientedPoint>();
        frontTop.Add(sideTop[0]); frontTop.Add(edgeTop[0]);

        // Rear face
        List<OrientedPoint> backBottom = new List<OrientedPoint>();
        backBottom.Add(side.Last()); backBottom.Add(edge.Last());

        List<OrientedPoint> backTop = new List<OrientedPoint>();
        backTop.Add(sideTop.Last()); backTop.Add(edgeTop.Last());

        // Side faces share vertices with the top and bottom faces
        int length = path.Count;

        // Create the base mesh, triangles and vertices
        Mesh mesh = new Mesh();

        // Similar to road extrusion code, modified for prismatic house meshes
        List<Vector3> vertices = new List<Vector3>(); //[length * 8 + 8];
        List<int> triangles = new List<int>(); //[6 * (length - 1) * 4 + 4];
        List<Vector2> uvs = new List<Vector2>();

        // Calculate each face of the house separately and add to the final mesh
        // Top face 
        triangles.AddRange(CalculateTriangleIndices(length));
        vertices.AddRange(CalculateVertices(sideTop, edgeTop, orientation, ref uvs));

        // Right face
        triangles.AddRange(CalculateTriangleIndices(length, vertices.Count));
        vertices.AddRange(CalculateVertices(sideTop, side, !orientation, ref uvs));

        // Left face
        triangles.AddRange(CalculateTriangleIndices(length, vertices.Count));
        vertices.AddRange(CalculateVertices(edgeTop, edge, orientation, ref uvs));

        // Bottom face  
        triangles.AddRange(CalculateTriangleIndices(length, vertices.Count));
        vertices.AddRange(CalculateVertices(side, edge, !orientation, ref uvs));

        // Front Face
        triangles.AddRange(CalculateTriangleIndices(2, vertices.Count));
        vertices.AddRange(CalculateVertices(frontBottom, frontTop, !orientation, ref uvs));

        // Back Face
        triangles.AddRange(CalculateTriangleIndices(2, vertices.Count));
        vertices.AddRange(CalculateVertices(backBottom, backTop, orientation, ref uvs));

        // Update mesh
        mesh.Clear();
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();
        mesh.uv = uvs.ToArray();
        mesh.RecalculateNormals();

        return mesh;
    }

    Vector3[] CalculateVertices(List<OrientedPoint> pathOne, List<OrientedPoint> pathTwo, bool orientation, ref List<Vector2> uvs)
    {
        // Function for calculating triangle indices between two paths for a single face of the prism (house)
        // Length of the paths (must be of equal length)
        int length = pathOne.Count;
        // Similar to road extrusion code, only the "width" here is always one


        Vector3[] vertices = new Vector3[length * 2];


        // Add vertices to vertices array
        if (orientation)
        {
            for (int i = 0, vert = 0; i < length; i++)
            {
                // Add both path and edge as vertices
                vertices[vert] = pathOne[i].position;
                uvs.Add(new Vector2(pathOne[i].position.x, vert));
                vert++;
                vertices[vert] = pathTwo[i].position;
                uvs.Add(new Vector2(pathTwo[i].position.x, vert));
                vert++;
            }
        }

        else
        {
            for (int i = 0, vert = 0; i < length; i++)
            {
                // Add both path and edge as vertices
                vertices[vert] = pathTwo[i].position;
                uvs.Add(new Vector2(pathTwo[i].position.x, vert));
                vert++;
                vertices[vert] = pathOne[i].position;
                uvs.Add(new Vector2(pathOne[i].position.x, vert));
                vert++;
            }
        }

        //Debug.Log("Length: " + length + "\nVertices: " + vertices.Length);

        return vertices;
    }

    int[] CalculateTriangleIndices(int length, int indexOffset = 0)
    {

        int[] triangles = new int[6 * (length - 1)];
        // Calculate triangle indices (same method as Road script)
        int triIdx = 0, vertIdx = indexOffset;
        for (int j = 0; j < length - 1; j++)
        {
            triangles[triIdx] = vertIdx;
            triangles[triIdx + 1] = vertIdx + 2;
            triangles[triIdx + 2] = vertIdx + 1;

            triangles[triIdx + 3] = vertIdx + 1;
            triangles[triIdx + 4] = vertIdx + 2;
            triangles[triIdx + 5] = vertIdx + 3;
            triIdx += 6;
            vertIdx += 2;
        }
        // Debug.Log("vertIdx after loop:" + vertIdx);
        return triangles;
    }

    public GameObject NewHouse()
    {
        GameObject house = new GameObject();
        house.name = "house";

        house.transform.position += new Vector3(0, 0.1f, 0);
        house.transform.parent = this.transform;
        house.AddComponent<MeshFilter>();
        house.AddComponent<MeshRenderer>();
        house.AddComponent<MeshCollider>();

        return house;
    }

    Tuple<int, List<OrientedPoint>> GetSubpath(List<OrientedPoint> path, int idx, int length, bool orientation)
    {
        // Function for getting a subpath from a list of oriented points from index to length
        List<OrientedPoint> subpath = new List<OrientedPoint>();

        int i = idx;
        while (i < idx + length && i < path.Count)
        {
            // If the current node is found to have >2 neighbors, the subpath is returned along
            // with the index for the next iteration
            if (path[i].neighbors.Count > 2)
            {
                return new Tuple<int, List<OrientedPoint>>(i + 2, subpath);
            }

            // Check for conflicting mesh colliders (houses) using raycast to their mesh colliders
            Debug.Log("Raycast: " + Physics.Raycast(path[i].position + Vector3.up * 5f, path[i].rotation * Vector3.left, 10f));
            Vector3 origin = path[i].position + Vector3.up * 5f;
            if (orientation && Physics.Raycast(origin, path[i].rotation * Vector3.right, 30f))
            {
                Debug.Log("Collision detected to the left");
                Debug.DrawRay(path[i].position, path[i].rotation * Vector3.right * 30f);
                i++;
                continue;
            }
            else if (!orientation && Physics.Raycast(origin, path[i].rotation * Vector3.left, 30f))
            {
                Debug.Log("Collision detected to the right");
                Debug.DrawRay(path[i].position, path[i].rotation * Vector3.left * 30f);
                i++;
                continue;
            }
            else
            {
                // Points are added to the subpath if no collisions are previously found
                subpath.Add(path[i]);
                i++;
            }
        }

        return new Tuple<int, List<OrientedPoint>>(idx + length, subpath);
    }

    void PlaceHouse(List<OrientedPoint> path, int roadLength, bool orientation)
    {
        // Initial parameters for building generation
        int idx = 0;
        int length = rnd.Next(3, 10);

        int[] heights = new int[12] {
            15, 16, 17, 19, 21, 23, 27, 33, 39, 43, 51, 110
        };
        while (idx < roadLength)
        {
            // Place an empty lot (for variation)
            if (rnd.Next(0, 100) < 10)
            {
                idx += length - 1;
                length = rnd.Next(1, 4);
                continue;
            }

            // Get subpath from idx and "length" forward
            Tuple<int, List<OrientedPoint>> subpath = GetSubpath(path, idx, length, orientation);

            // Update idx and calculate length for next house
            idx = subpath.Item1 - 1;
            length = rnd.Next(3, 10);

            if (subpath.Item2.Count <= 2) { continue; }

            // Build house
            GameObject house = NewHouse();
            int height = heights[rnd.Next(0, 12)];
            Mesh houseMesh = CurvedHouse(subpath.Item2, 4, rnd.Next(20, 30), height, orientation);
            house.GetComponent<MeshFilter>().sharedMesh = houseMesh;
            house.GetComponent<MeshCollider>().sharedMesh = houseMesh;
            house.GetComponent<MeshCollider>().convex = true;
            
            // Materials
            Material bldgMat = Resources.Load("building", typeof(Material)) as Material;
            house.GetComponent<MeshRenderer>().material = bldgMat;
        }
    }

    public void BuildHouses(List<OrientedPoint>[,] roadPoints)
    {
        // Get all the roads from the road network
        GameObject roadNetwork = GameObject.Find("CityGenerator/Road Network");


        // Get all the children of the road network (transforms)
        foreach (Transform road in roadNetwork.transform)
        {
            // Get the current road path
            List<OrientedPoint> path = road.gameObject.GetComponent<Road>().path;
            int roadLength = path.Count;

            // Check if the path variable in that particular road is empty
            if (roadLength == 0) { continue; }

            // Place houses on left and right side of the path
            PlaceHouse(path, roadLength, true);
            PlaceHouse(path, roadLength, false);

        }


        /*
        GameObject mainRoad = GameObject.Find("Main Road");

        List<OrientedPoint> path = mainRoad.gameObject.GetComponent<Road>().path;
        int roadLength = path.Count;

        // Place houses on left and right side of the path
        PlaceHouse(path, roadLength, true);
        PlaceHouse(path, roadLength, false);
        */
    }
}