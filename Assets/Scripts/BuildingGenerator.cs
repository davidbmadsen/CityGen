using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class BuildingGenerator : MonoBehaviour
{
    // Class for generating buildings based on the road network generated by the RoadNetwork class
    // Generate some houses ya bish
    System.Random rnd = new System.Random();
    Mesh mesh;

    List<OrientedPoint> OffsetPath(List<OrientedPoint> path, int offset, bool orientation)
    {
        // Function for offsetting a path perpendicular in either right (orientation = true) 
        // or left of the original path

        List<OrientedPoint> offsetPath = new List<OrientedPoint>();

        if (orientation)
        {
            foreach (OrientedPoint point in path)
            {
                offsetPath.Add(new OrientedPoint(
                    point.position + point.rotation * Vector3.right * offset,
                    point.rotation,
                    0,
                    new List<OrientedPoint>()
                ));
            }
        }
        else
        {
            foreach (OrientedPoint point in path)
            {
                offsetPath.Add(new OrientedPoint(
                    point.position + point.rotation * Vector3.left * offset,
                    point.rotation,
                    0,
                    new List<OrientedPoint>()
                ));
            }
        }

        return offsetPath;
    }

    Mesh CurvedHouse(List<OrientedPoint> path, int distanceFromRoad, int width, bool orientation)
    {
        // Create vertices that is "width" out from the path
        // Not the same as width in the Road generator script
        List<OrientedPoint> side = OffsetPath(path, distanceFromRoad, orientation);
        List<OrientedPoint> edge = OffsetPath(path, width, orientation);

        int length = path.Count;

        // Create the base mesh, triangles and vertices
        Mesh mesh = new Mesh();

        // Similar to road extrusion code, only the "width" here is always one
        Vector3[] vertices = new Vector3[length * 2];
        int[] triangles = new int[6 * (length - 1)];

        // Add vertices to vertices array
        if (orientation)
        {
            for (int i = 0, vert = 0; i < length; i++)
            {
                // Add both path and edge as vertices
                vertices[vert] = side[i].position + side[i].rotation * Vector3.right;
                vert++;
                vertices[vert] = edge[i].position;
                vert++;
            }
        }
        else
        {
            for (int i = 0, vert = 0; i < length; i++)
            {
                // Add both path and edge as vertices
                vertices[vert] = edge[i].position;
                vert++;
                vertices[vert] = side[i].position + side[i].rotation * Vector3.left;
                vert++;
            }
        }


        // Calculate triangle indices (same method as Road script)
        int triIdx = 0, vertIdx = 0;
        for (int j = 0; j < length - 1; j++)
        {
            triangles[triIdx] = vertIdx;
            triangles[triIdx + 1] = vertIdx + 2;
            triangles[triIdx + 2] = vertIdx + 1;

            triangles[triIdx + 3] = vertIdx + 1;
            triangles[triIdx + 4] = vertIdx + 2;
            triangles[triIdx + 5] = vertIdx + 3;
            triIdx += 6;
            vertIdx += 2;
        }

        // Update mesh
        mesh.Clear();
        mesh.vertices = vertices;
        mesh.triangles = triangles;
        mesh.RecalculateNormals();

        return mesh;
    }

    public GameObject NewHouse()
    {
        GameObject house = new GameObject();
        house.name = "house";

        house.transform.position += new Vector3(0, 0.1f, 0);
        house.transform.parent = this.transform;
        house.AddComponent<MeshFilter>();
        house.AddComponent<MeshRenderer>();

        return house;
    }

    Tuple<int, List<OrientedPoint>> GetSubpath(List<OrientedPoint> path, int idx, int length)
    {
        // Function for getting a subpath from a list of oriented points from index to length
        List<OrientedPoint> subpath = new List<OrientedPoint>();

        int i = idx;
        while (i < idx + length && i < path.Count)
        {
            // If the current node is found to have >2 neighbors, the subpath is returned along
            // with the index for the next iteration
            if (path[i].neighbors.Count > 2) 
            {
                return new Tuple<int, List<OrientedPoint>>(i + 2, subpath);
            }

            // Each iteration of the while-loop, points are added to the subpath
            subpath.Add(path[i]);

            i++;
        }

        return new Tuple<int, List<OrientedPoint>>(idx + length, subpath);
    }

    void PlaceHouse(List<OrientedPoint> path, int roadLength, bool orientation)
    {
        // Initial parameters for building generation
        int idx = 0;
        int length = rnd.Next(3, 10);
        while (idx < roadLength)
        {
            // Place an empty lot (for variation)
            if (rnd.Next(0, 100) < 10)
            {
                idx += length - 1;
                length = rnd.Next(1, 4);
                continue;
            }

            // Get subpath from idx and "length" forward
            Tuple<int, List<OrientedPoint>> subpath = GetSubpath(path, idx, length);

            // Update idx and calculate length for next house
            idx = subpath.Item1 - 1;
            length = rnd.Next(3, 10);

            if (subpath.Item2.Count <= 2) { continue; }

            // Build house
            GameObject house = NewHouse();
            house.GetComponent<MeshFilter>().mesh = CurvedHouse(subpath.Item2, 4, rnd.Next(20, 30), orientation);
        }
    }

    public void BuildHouses(List<OrientedPoint>[,] roadPoints)
    {
        // Get all the roads from the road network
        GameObject roadNetwork = GameObject.Find("CityGenerator/Road Network");

        /*
        // Get all the children of the road network (transforms)
        foreach (Transform road in roadNetwork.transform)
        {
            // Get the current road path
            List<OrientedPoint> path = road.gameObject.GetComponent<Road>().path;
            int roadLength = path.Count;

            // Check if the path variable in that particular road is empty
            if (roadLength == 0) { continue; }

            // Place houses on left and right side of the path
            PlaceHouse(path, roadLength, true);
            PlaceHouse(path, roadLength, false);

        }
        */
        GameObject mainRoad = GameObject.Find("Main Road");

        List<OrientedPoint> path = mainRoad.gameObject.GetComponent<Road>().path;
        int roadLength = path.Count;

        // Place houses on left and right side of the path
        PlaceHouse(path, roadLength, true);
        PlaceHouse(path, roadLength, false);
    }
}

